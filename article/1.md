开发时习惯将调用后端接口的方法写在接口文件里统一管理，
 这样使用时需要import方法，
 类似在页面里 import { fun1,fun2,fun3 } from ../api/user
 每次都需要import,非常不方便

下面这种方法解决每次import问题：



![img](https:////upload-images.jianshu.io/upload_images/26125837-dfdf422958ca90ae.png?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp)

image.png

封装成图上这种后
 组件内要调用api使用的时候直接   this.$api.user.func1()....
 很方便快捷哈，不用   import { fun1,fun2,fun3 } from ../api/user

封装代码，在index.js



```jsx
import Vue from 'vue'
import * as DS from './DS'
import * as content from './content'
import * as user from './user'

const api = {
  DS,
  content,
  user
}

Vue.prototype.$api = api

export default api
```

main.js



```dart
import '@/api'
```

------

------

对于这种只有一层级的接口文件，我们可以像上面这么处理

多层级怎么处理呢？



![img](https:////upload-images.jianshu.io/upload_images/26125837-6beabefab42250ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/457/format/webp)

image.png



图上api接口文件夹下，既有第一层级的login.js, menu.js ，还有第二层级在monitor文件夹下的job.js, server.js  。。。。。像这种可以用下面的方式处理~

src / api / index.js



```jsx
import Vue from 'vue'
import * as login from './login'
import * as menu from './menu'
import * as monitor from './monitor/index'

console.log(2222222)
console.log(monitor)
const api = {
    login,
    monitor,
    menu
}

Vue.prototype.$api = api

// export default api
```



 src / api / monitor / index.js



```jsx
import * as job from "./job"
import * as server from "./server"

export {job,server}
```



 src / main.js



```dart
import '@/api'
```



 页面



```tsx
this.$api.login.func1().then(res => { ...............

this.$api.monitor.job.func1().then(res => { ...............
```



> 思想就是 ：
>
> 同一层级的文件直接引入 然后挂载，多层级的文件，分文件夹用index.js把本文件夹下的文件全部引入进去，然后导出，再在外层的index文件 引用里层的index文件，就能把所有文件内容一次导出了




 接口.js文件内容如下

![img](https:////upload-images.jianshu.io/upload_images/26125837-cb145ec8feb35aa1.png?imageMogr2/auto-orient/strip|imageView2/2/w/827/format/webp)

image.png







#### 路由传参常用方式有以下几种

1. 通过url传参

   

   ```js
   // 产品列表页面
    <navigator url="/pages/detail/detail?productId=12345" hover-class="navigator-hover">详情</navigator>
   
   // 或者
   wx.navigateTo({
     url: '/pages/detail/detail?productId=12345'
   })
   ```

   

   ```js
   // 产品详情页面
   Page({
     onLoad: function(option){
       let productId = option.productId;
       console.log(productId);
     }
   })
   ```

   上面的方式的参数不能是对象,如果需要传对象,可以将对象转成json字符串,然后拼接到url后面,在接收页面再将json字符串转成对象

   

   ```js
   let info = {
    a:2,
    b:3
   }
   let infoStr = JSON.stringfy(info);
   wx.navigateTo({
     url: '/pages/detail/detail?infoStr='+infoStr
   })
   ```

   

   ```js
   // 产品详情页面
   Page({
     onLoad: function(option){
       let infoStr = option.infoStr;
       let info = JSON.parse(infoStr);
     }
   })
   ```

1. 通过事件传参

   1. 官网例子

   

   ```js
   // 产品列表页
   wx.navigateTo({
     url: url: '/pages/detail/detail'
     events: {
       // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据
       acceptDataFromOpenedPage: function(data) {
         console.log(data)
       },
       someEvent: function(data) {
         console.log(data)
       }
       ...
     },
     success: function(res) {
       // 通过eventChannel向被打开页面传送数据
       res.eventChannel.emit('acceptDataFromOpenerPage', { data: 'test' })
     }
   })
   ```

   

   ```js
   // 产品详情页
   Page({
     onLoad: function(option){
       const eventChannel = this.getOpenerEventChannel()
       eventChannel.emit('acceptDataFromOpenedPage', {data: 'test'});
       eventChannel.emit('someEvent', {data: 'test'});
       // 监听acceptDataFromOpenerPage事件，获取上一页面通过eventChannel传送到当前页面的数据
       eventChannel.on('acceptDataFromOpenerPage', function(data) {
         console.log(data)
       })
     }
   })
   ```

1. 简化例子
    以上例子,在跳转的时候列表页可以向详情页传数据,详情页也可以向列表页传数据,平时我们经常都只是传数据,很少需要回传,以下是简化的例子



```js
// 列表页
wx.navigateTo({
  url: "/pages/home/detail/detail",
  success: function(res) {
    // 通过eventChannel向被打开页面传送数据
    let data = {productId: 'sadf2323',productName:'金龙鱼花生油'};
    res.eventChannel.emit("info", data);
  }
});
```



```js
// 详情页
onLoad: function(options) {
  const eventChannel = this.getOpenerEventChannel();
  // 监听info事件，获取上一页面通过eventChannel传送到当前页面的数据
  eventChannel.on("info", function(data) {
     console.log(data);
  });
},
```

总结: 路由传参可以用这两种方式

1. 通过url拼接参数传输,需要传对象,需要传对象就先讲对象转成json字符串再传
2. 通过eventChannel(事件通道)进行传输(可以传对象)

小程序提供了全局的 getApp() 方法，可获取当前小程序实例，一般用于在子页面中获取顶层应用。



```cpp
// app.js
App({
  globalData: 1
});
```



```jsx
// page.js
var app = getApp();
console.log(app.globalData); // 获取 globalData
```



缓存写入



```bash
wx.setStorageSync('password', password);

wx.setStorageSync('mobile', mobile);
```

缓存读取、移除、清除所有



```csharp
var mobile = wx.getStorageSync('mobile');

wx.removeStorageSync('mobile');

wx.clearStorage();
```



提示信息和弹框，有icon时最多显示7个字，icon为none时可显示全部信息。



```jsx
wx.showToast({

title: '登录成功',

success: function () {

setTimeout(function () {

//要延时执行的代码
```

//跳转到成功页面



```csharp
wx.switchTab({

url: '../index/index'

})

}, 2000) //延迟时间

}

})
```

模态框，确认取消对话框



```php
wx.showModal({

title: '确认',

content: '确认提交订单',

success: function (res) {

if (res.confirm) {

console.log('确定')

}else{

console.log(取消')

}

}

})
```







































```css
div {
    width: 200px;
    height: 200px;
    border: 10px solid red;
    /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */
    /* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */
    box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);
```



| 值       | 描述                                   |
| :------- | :------------------------------------- |
| h-shadow | 必需。水平阴景拍的位置。允许负值。     |
| v-shadow | 必需。垂直阴景拍的位置。允许负值。     |
| blur     | 可选。模糊距离。                       |
| spread   | 可选。阴景的尺寸。                     |
| color    | 可选。阴景的颜色。请参阅CSS颜色值。    |
| inset    | 可选。将外部阴影(outset)改为内部阴影。 |

：text-shadow: 水平偏移量 垂直偏移量 模糊度 颜色

box:hover img和.box img:hover的区别

.box:hover img：意思为鼠标经过.box里面的img发生变化

.box img:hover：意思为经过box里面的img时发生变化



